<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Emoji Memory Card Game</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<style>
body {
margin: 0;
display: flex;
justify-content: center;
align-items: center;
height: 100vh;
background: #f0f0f0;
font-family: Arial, sans-serif;
}
canvas {
border: 3px solid #333;
border-radius: 10px;
}
</style>
</head>
<body>

<script>
let gameState = "SPLASH";
let previousGameState = "HOME";
let cards = [];
let flippedCards = [];
let lockBoard = false;
let matchesFound = 0;
let moves = 0;
let particleSystems = [];
let startTime, currentTimer = 0;
let gameCompleted = false;
let isPaused = false;
let pauseStartTime = 0;
let totalPausedTime = 0;
let wasPausedBeforeReset = false;

let bestTimes = {
ANIMALS: Infinity,
FOOD: Infinity,
FACES: Infinity,
MIX: Infinity
};

let bestMoves = {
ANIMALS: Infinity,
FOOD: Infinity,
FACES: Infinity,
MIX: Infinity
};

const themes = {
ANIMALS: ['ðŸ¶', 'ðŸ±', 'ðŸ­', 'ðŸ¹', 'ðŸ°', 'ðŸ¦Š', 'ðŸ»', 'ðŸ¼'],
FOOD: ['ðŸŽ', 'ðŸ“', 'ðŸ•', 'ðŸŒ®', 'ðŸ¦€', 'ðŸ©', 'ðŸ”', 'ðŸ¥¨'],
FACES: ['ðŸ˜€', 'ðŸ˜Ž', 'ðŸ˜œ', 'ðŸ¤©', 'ðŸ¤”', 'ðŸ¤ ', 'ðŸ¥³', 'ðŸ‘»'],
MIX: []
};

let selectedThemeName = "ANIMALS";
let selectedTheme = themes.ANIMALS;

const BTN_W = 180;
const BTN_H = 50;
const PRIMARY_COLOR = "#4682B4";
const BACK_COLOR = "#CD5C5C";

function setup() {
createCanvas(450, 450);
loadBestTimes();
loadBestMoves();
}

function loadBestTimes() {
try {
let data = localStorage.getItem('emojiGameBestTimes');
if (data) {
let loaded = JSON.parse(data);
bestTimes.ANIMALS = loaded.ANIMALS || Infinity;
bestTimes.FOOD = loaded.FOOD || Infinity;
bestTimes.FACES = loaded.FACES || Infinity;
bestTimes.MIX = loaded.MIX || Infinity;
}
} catch(e) {
console.log("Error loading times");
}
}

function saveBestTimes() {
try {
localStorage.setItem('emojiGameBestTimes', JSON.stringify(bestTimes));
} catch(e) {
console.log("Error saving times");
}
}

function loadBestMoves() {
try {
let data = localStorage.getItem('emojiGameBestMoves');
if (data) {
let loaded = JSON.parse(data);
bestMoves.ANIMALS = loaded.ANIMALS || Infinity;
bestMoves.FOOD = loaded.FOOD || Infinity;
bestMoves.FACES = loaded.FACES || Infinity;
bestMoves.MIX = loaded.MIX || Infinity;
}
} catch(e) {
console.log("Error loading moves");
}
}

function saveBestMoves() {
try {
localStorage.setItem('emojiGameBestMoves', JSON.stringify(bestMoves));
} catch(e) {
console.log("Error saving moves");
}
}

function initGame() {
cards = [];
flippedCards = [];
matchesFound = 0;
moves = 0;
startTime = millis();
gameCompleted = false;
isPaused = false;
pauseStartTime = 0;
totalPausedTime = 0;

if (selectedThemeName === "MIX") {
themes.MIX = [...themes.ANIMALS, ...themes.FOOD, ...themes.FACES]
.sort(() => Math.random() - 0.5)
.slice(0, 8);
selectedTheme = themes.MIX;
} else {
selectedTheme = themes[selectedThemeName];
}

let deck = [...selectedTheme, ...selectedTheme].sort(() => Math.random() - 0.5);
let cols = 4, rows = 4;
let w = width / cols, h = height / (rows + 0.5);

for (let i=0; i<cols; i++) {
for (let j=0; j<rows; j++) {
cards.push(new Card(i*w, j*h+45, w, h, deck[i*rows+j]));
}
}
}

function draw() {
background(255);

if (gameState === "SPLASH") {
textSize(24);
let linkText = "Here's the link ";
let linkURL = "https://cash.app/";
let totalWidth = textWidth(linkText + linkURL);
let startX = width/2 - totalWidth/2;
let linkURLStartX = startX + textWidth(linkText);
let linkURLEndX = linkURLStartX + textWidth(linkURL);

if (mouseX>linkURLStartX && mouseX<linkURLEndX && mouseY>210 && mouseY<240) {
cursor(HAND);
} else if (isMouseOver(width/2, 340, BTN_W, BTN_H)) {
cursor(HAND);
} else {
cursor(ARROW);
}

textAlign(CENTER, CENTER);
fill(0); 
textSize(36);
text("Support Me", width/2, 80);

textSize(24);
text("Support me by Cash Apping me", width/2, 160);
text("My Cash App is $DannyCejka2", width/2, 200);

textAlign(LEFT, CENTER);
fill(0);
text(linkText, startX, 240);
fill(0, 100, 200);
text(linkURL, linkURLStartX, 240);

textAlign(CENTER, CENTER);
fill(0);
drawCustomButton("CONTINUE", width/2, 340, BTN_W, BTN_H, PRIMARY_COLOR);

} else if (gameState === "HOME") {
if (isMouseOver(width/2, 180, BTN_W, BTN_H) || isMouseOver(width/2, 260, BTN_W, BTN_H) || isMouseOver(width/2, 340, BTN_W, BTN_H)) {
cursor(HAND);
} else {
cursor(ARROW);
}

textAlign(CENTER, CENTER);
fill(0); 
textSize(32);
text("Emoji Memory Card Game", width/2, 90);
drawCustomButton("PLAY", width/2, 180, BTN_W, BTN_H, PRIMARY_COLOR);
drawCustomButton("HOW TO PLAY", width/2, 260, BTN_W, BTN_H, PRIMARY_COLOR);
drawCustomButton("CREDITS", width/2, 340, BTN_W, BTN_H, PRIMARY_COLOR);
drawLogo(width-70, height-55);

} else if (gameState === "RESET_CONFIRM") {
if (isMouseOver(width/2-90, height/2+40, 120, 50) || isMouseOver(width/2+90, height/2+40, 120, 50)) {
cursor(HAND);
} else {
cursor(ARROW);
}

if (previousGameState === "PLAY") {
// Display frozen game state in background
textAlign(LEFT, TOP);
textSize(16); 
fill(50);
text(`Time: ${(currentTimer/1000).toFixed(1)}s`, 15, 10);
text(`Moves: ${moves}`, 15, 28);

let themeDisplay = selectedThemeName.charAt(0) + selectedThemeName.slice(1).toLowerCase() + " Theme";
let themeY = 10 + (28 - 10) / 2;
textAlign(CENTER, CENTER);
text(themeDisplay, width/2, themeY);

let bt = bestTimes[selectedThemeName]===Infinity ? "--" : (bestTimes[selectedThemeName]/1000).toFixed(1)+"s";
let bm = bestMoves[selectedThemeName]===Infinity ? "--" : bestMoves[selectedThemeName];
textAlign(RIGHT, TOP);
text(`Best Time: ${bt}`, width-15, 10);
text(`Best Moves: ${bm}`, width-15, 28);

for (let c of cards) { 
c.display(); 
}
} else if (previousGameState === "HOME") {
textAlign(CENTER, CENTER);
fill(0); 
textSize(32);
text("Emoji Memory Card Game", width/2, 90);
drawCustomButton("PLAY", width/2, 180, BTN_W, BTN_H, PRIMARY_COLOR);
drawCustomButton("HOW TO PLAY", width/2, 260, BTN_W, BTN_H, PRIMARY_COLOR);
drawCustomButton("CREDITS", width/2, 340, BTN_W, BTN_H, PRIMARY_COLOR);
drawLogo(width-70, height-55);
} else if (previousGameState === "MODES") {
textAlign(CENTER, CENTER);
fill(0); 
textSize(24);
text("Choose Your Theme", width/2, 40);

let m = ["ANIMALS", "FOOD", "FACES", "MIX"];
let icons = ["ðŸ¶", "ðŸ•", "ðŸ˜Ž", "ðŸ”€"];

for (let i=0; i<m.length; i++) {
let bt = bestTimes[m[i]]===Infinity ? "--" : (bestTimes[m[i]]/1000).toFixed(1)+"s";
let bm = bestMoves[m[i]]===Infinity ? "--" : bestMoves[m[i]];
let yPos = 100+(i*70);
drawCustomButton(`${m[i]} ${icons[i]}`, width/2, yPos, BTN_W, BTN_H, PRIMARY_COLOR);
textSize(11); 
fill(100);
textAlign(LEFT, CENTER);
text(`Best Time: ${bt}`, width/2+95, yPos-8);
text(`Best Moves: ${bm}`, width/2+95, yPos+8);
textAlign(CENTER, CENTER);
textSize(24);
}

drawCustomButton("BACK TO HOME", width/2, 400, BTN_W, BTN_H, BACK_COLOR);
} else if (previousGameState === "HOW_TO_PLAY") {
fill(0);
textAlign(CENTER, CENTER);
textSize(30);
text("How to Play", width/2, 60);

textSize(14);
let startY = 150;
let lineGap = 22;
text("Click any two cards to reveal the emojis.", width/2, startY);
text("Find all 8 matching pairs to win the game!", width/2, startY + lineGap);
text("Your time and moves will be recorded and", width/2, startY + lineGap*2);
text("saved as the best time and moves for that specific game mode.", width/2, startY + lineGap*3);
text("Press P to pause during gameplay.", width/2, startY + lineGap*4);
text("Press R to reset all your best scores and moves.", width/2, startY + lineGap*5);

drawCustomButton("BACK TO HOME", width/2, 370, BTN_W, BTN_H, BACK_COLOR);
} else if (previousGameState === "CREDITS") {
fill(0);
textAlign(CENTER, CENTER);
textSize(30);
text("Credits", width/2, 80);

textSize(20);
let startY = 190;
let lineGap = 26;
text("Game Design & Programming", width/2, startY);
text("by", width/2, startY + lineGap);
text("Daniel Cejka", width/2, startY + lineGap*2);

drawCustomButton("BACK TO HOME", width/2, 370, BTN_W, BTN_H, BACK_COLOR);
}

fill(0, 0, 0, 200);
rectMode(CORNER);
rect(0, 0, width, height);

rectMode(CENTER);
fill(255);
noStroke();
rect(width/2, height/2, 360, 220, 10);

textAlign(CENTER, CENTER);
fill(0);
textSize(18);
text("Are you sure that you would like\nto reset your best scores and moves?\nThis will not affect your current game.", width/2, height/2-50);

drawCustomButton("CANCEL", width/2-90, height/2+40, 120, 50, "#CD5C5C");
drawCustomButton("CONFIRM", width/2+90, height/2+40, 120, 50, "#32CD32");

} else if (gameState === "MODES") {
let overButton = false;
for (let i=0; i<4; i++) {
if (isMouseOver(width/2, 100+(i*70), BTN_W, BTN_H)) {
overButton = true;
break;
}
}
if (overButton || isMouseOver(width/2, 400, BTN_W, BTN_H)) {
cursor(HAND);
} else {
cursor(ARROW);
}

textAlign(CENTER, CENTER);
fill(0); 
textSize(24);
text("Choose Your Theme", width/2, 40);

let m = ["ANIMALS", "FOOD", "FACES", "MIX"];
let icons = ["ðŸ¶", "ðŸ•", "ðŸ˜Ž", "ðŸ”€"];

for (let i=0; i<m.length; i++) {
let bt = bestTimes[m[i]]===Infinity ? "--" : (bestTimes[m[i]]/1000).toFixed(1)+"s";
let bm = bestMoves[m[i]]===Infinity ? "--" : bestMoves[m[i]];
let yPos = 100+(i*70);
drawCustomButton(`${m[i]} ${icons[i]}`, width/2, yPos, BTN_W, BTN_H, PRIMARY_COLOR);
textSize(11); 
fill(100);
textAlign(LEFT, CENTER);
text(`Best Time: ${bt}`, width/2+95, yPos-8);
text(`Best Moves: ${bm}`, width/2+95, yPos+8);
textAlign(CENTER, CENTER);
textSize(24);
}

drawCustomButton("BACK TO HOME", width/2, 400, BTN_W, BTN_H, BACK_COLOR);

} else if (gameState === "PLAY") {
if (isPaused) {
if (isMouseOver(width/2, height/2+30, 140, 50)) {
cursor(HAND);
} else {
cursor(ARROW);
}
} else if (matchesFound === 8) {
if (isMouseOver(width/2, height/2+60, 260, BTN_H)) {
cursor(HAND);
} else {
cursor(ARROW);
}
} else {
let overCard = false;
for (let c of cards) {
if (c.isClicked(mouseX, mouseY) && !c.revealed && flippedCards.length<2 && !lockBoard) {
overCard = true;
break;
}
}
if (overCard) {
cursor(HAND);
} else {
cursor(ARROW);
}
}

// CRITICAL: Only update timer if NOT paused and game not completed
if (matchesFound<8 && !isPaused) {
currentTimer = millis() - startTime - totalPausedTime;
}

textAlign(LEFT, TOP);
textSize(16); 
fill(50);
text(`Time: ${(currentTimer/1000).toFixed(1)}s`, 15, 10);
text(`Moves: ${moves}`, 15, 28);

let themeDisplay = selectedThemeName.charAt(0) + selectedThemeName.slice(1).toLowerCase() + " Theme";
let themeY = 10 + (28 - 10) / 2;
textAlign(CENTER, CENTER);
text(themeDisplay, width/2, themeY);

let bt = bestTimes[selectedThemeName]===Infinity ? "--" : (bestTimes[selectedThemeName]/1000).toFixed(1)+"s";
let bm = bestMoves[selectedThemeName]===Infinity ? "--" : bestMoves[selectedThemeName];
textAlign(RIGHT, TOP);
text(`Best Time: ${bt}`, width-15, 10);
text(`Best Moves: ${bm}`, width-15, 28);

// CRITICAL: Only update cards if NOT paused
for (let c of cards) { 
if (!isPaused) {
c.update(mouseX, mouseY, !lockBoard && flippedCards.length<2 && matchesFound<8); 
}
c.display(); 
}

// CRITICAL: Only update particles if NOT paused
if (!isPaused) {
for (let i=particleSystems.length-1; i>=0; i--) {
particleSystems[i].update();
particleSystems[i].display();
if (particleSystems[i].isFinished()) {
particleSystems.splice(i, 1);
}
}
} else {
// Still display particles when paused, just don't update them
for (let i=particleSystems.length-1; i>=0; i--) {
particleSystems[i].display();
}
}

if (isPaused) {
fill(0, 0, 0, 200);
rectMode(CORNER);
rect(0, 0, width, height);

textAlign(CENTER, CENTER);
fill(255);
textSize(48);
text("PAUSED", width/2, height/2-40);

drawCustomButton("UNPAUSE", width/2, height/2+30, 140, 50, "#32CD32");
}

if (matchesFound === 8) {
if (!gameCompleted) {
gameCompleted = true;
if (currentTimer < bestTimes[selectedThemeName]) {
bestTimes[selectedThemeName] = currentTimer;
saveBestTimes();
}
if (moves < bestMoves[selectedThemeName]) {
bestMoves[selectedThemeName] = moves;
saveBestMoves();
}
}

fill(255, 230);
rect(width/2, height/2, width, height);

textAlign(CENTER, CENTER);
fill(0, 150, 0); 
textSize(40);
text("ðŸŽ‰ YOU WIN! ðŸŽ‰", width/2, height/2-40);

fill(0);
textSize(18);
text(`Time: ${(currentTimer/1000).toFixed(1)}s | Moves: ${moves}`, width/2, height/2);

drawCustomButton("BACK TO HOME SCREEN", width/2, height/2+60, 260, BTN_H, BACK_COLOR);
}

} else if (gameState === "HOW_TO_PLAY") {
if (isMouseOver(width/2, 370, BTN_W, BTN_H)) {
cursor(HAND);
} else {
cursor(ARROW);
}

fill(0);
textAlign(CENTER, CENTER);
textSize(30);
text("How to Play", width/2, 60);

textSize(14);
let startY = 150;
let lineGap = 22;
text("Click any two cards to reveal the emojis.", width/2, startY);
text("Find all 8 matching pairs to win the game!", width/2, startY + lineGap);
text("Your time and moves will be recorded and", width/2, startY + lineGap*2);
text("saved as the best time and moves for that specific game mode.", width/2, startY + lineGap*3);
text("Press P to pause during gameplay.", width/2, startY + lineGap*4);
text("Press R to reset all your best scores and moves.", width/2, startY + lineGap*5);

drawCustomButton("BACK TO HOME", width/2, 370, BTN_W, BTN_H, BACK_COLOR);

} else if (gameState === "CREDITS") {
if (isMouseOver(width/2, 370, BTN_W, BTN_H)) {
cursor(HAND);
} else {
cursor(ARROW);
}

fill(0);
textAlign(CENTER, CENTER);
textSize(30);
text("Credits", width/2, 80);

textSize(20);
let startY = 190;
let lineGap = 26;
text("Game Design & Programming", width/2, startY);
text("by", width/2, startY + lineGap);
text("Daniel Cejka", width/2, startY + lineGap*2);

drawCustomButton("BACK TO HOME", width/2, 370, BTN_W, BTN_H, BACK_COLOR);
}
}

function drawLogo(x, y) {
push();
textAlign(CENTER, CENTER);
fill(0); 
noStroke();
ellipse(x, y, 45, 45);
fill(255); 
textSize(13);
text("DVGS", x, y+1);
fill(0); 
textSize(10);
text("Danny's Video Game Studio", x, y+38);
pop();
}

function keyPressed() {
// Press R to show reset confirmation
if (key==='r' || key==='R') {
if (gameState!=="RESET_CONFIRM" && gameState!=="SPLASH") {
previousGameState = gameState;
wasPausedBeforeReset = isPaused;
if (gameState==="PLAY" && matchesFound<8 && !gameCompleted && !isPaused) {
pauseStartTime = millis();
isPaused = true;
}
gameState = "RESET_CONFIRM";
}
}
// Press P to pause the game (CRITICAL FIX)
if (gameState==="PLAY" && matchesFound<8 && !gameCompleted && !isPaused) {
if (key==='p' || key==='P') {
pauseStartTime = millis();
isPaused = true;
}
}
}

function mousePressed() {
if (gameState === "SPLASH") {
textSize(24);
let linkText = "Here's the link ";
let linkURL = "https://cash.app/";
let totalWidth = textWidth(linkText + linkURL);
let startX = width/2 - totalWidth/2;
let linkURLStartX = startX + textWidth(linkText);
let linkURLEndX = linkURLStartX + textWidth(linkURL);

if (mouseX>linkURLStartX && mouseX<linkURLEndX && mouseY>210 && mouseY<240) {
window.open("https://cash.app/", "_blank");
}
else if (isMouseOver(width/2, 340, BTN_W, BTN_H)) {
gameState = "HOME";
}

} else if (gameState === "HOME") {
if (isMouseOver(width/2, 180, BTN_W, BTN_H)) {
gameState = "MODES";
}
else if (isMouseOver(width/2, 260, BTN_W, BTN_H)) {
gameState = "HOW_TO_PLAY";
}
else if (isMouseOver(width/2, 340, BTN_W, BTN_H)) {
gameState = "CREDITS";
}

} else if (gameState === "RESET_CONFIRM") {
if (isMouseOver(width/2-90, height/2+40, 120, 50)) {
if (wasPausedBeforeReset) {
totalPausedTime += millis() - pauseStartTime;
} else if (previousGameState === "PLAY" && isPaused) {
totalPausedTime += millis() - pauseStartTime;
isPaused = false;
}
gameState = previousGameState;
} else if (isMouseOver(width/2+90, height/2+40, 120, 50)) {
bestTimes.ANIMALS = Infinity;
bestTimes.FOOD = Infinity;
bestTimes.FACES = Infinity;
bestTimes.MIX = Infinity;
bestMoves.ANIMALS = Infinity;
bestMoves.FOOD = Infinity;
bestMoves.FACES = Infinity;
bestMoves.MIX = Infinity;
saveBestTimes();
saveBestMoves();
isPaused = false;
gameState = "SPLASH";
}

} else if (gameState === "MODES") {
let m = ["ANIMALS", "FOOD", "FACES", "MIX"];
let yPositions = [100, 170, 240, 310];

if (isMouseOver(width/2, yPositions[0], BTN_W, BTN_H)) { 
selectedThemeName = m[0]; 
initGame(); 
gameState = "PLAY"; 
}
else if (isMouseOver(width/2, yPositions[1], BTN_W, BTN_H)) { 
selectedThemeName = m[1]; 
initGame(); 
gameState = "PLAY"; 
}
else if (isMouseOver(width/2, yPositions[2], BTN_W, BTN_H)) { 
selectedThemeName = m[2]; 
initGame(); 
gameState = "PLAY"; 
}
else if (isMouseOver(width/2, yPositions[3], BTN_W, BTN_H)) { 
selectedThemeName = m[3]; 
initGame(); 
gameState = "PLAY"; 
}
else if (isMouseOver(width/2, 400, BTN_W, BTN_H)) {
gameState = "HOME";
}

} else if (gameState === "HOW_TO_PLAY") {
if (isMouseOver(width/2, 370, BTN_W, BTN_H)) {
gameState = "HOME";
}

} else if (gameState === "CREDITS") {
if (isMouseOver(width/2, 370, BTN_W, BTN_H)) {
gameState = "HOME";
}

} else if (gameState === "PLAY") {
// CRITICAL: Handle unpause button click
if (isPaused) {
if (isMouseOver(width/2, height/2+30, 140, 50)) {
totalPausedTime += millis() - pauseStartTime;
isPaused = false;
}
return; // Don't process any other clicks when paused
}

if (matchesFound===8 && isMouseOver(width/2, height/2+60, 260, BTN_H)) {
gameState = "HOME";
} else if (!lockBoard) {
for (let c of cards) {
if (c.isClicked(mouseX, mouseY) && !c.revealed && flippedCards.length<2) {
c.flip();
flippedCards.push(c);

if (flippedCards.length === 2) {
moves++;
lockBoard = true;

if (flippedCards[0].val === flippedCards[1].val) {
particleSystems.push(new ParticleSystem(flippedCards[0].getCenter()));
particleSystems.push(new ParticleSystem(flippedCards[1].getCenter()));
matchesFound++;
flippedCards = [];
lockBoard = false;

} else {
setTimeout(() => {
flippedCards[0].flip();
flippedCards[1].flip();
flippedCards = [];
lockBoard = false;
}, 800);
}
}
}
}
}
}
}

function drawCustomButton(txt, x, y, w, h, c) {
rectMode(CENTER); 
noStroke(); 
fill(c);
rect(x, y, w, h, 5);
fill(255); 
textSize(16); 
textAlign(CENTER, CENTER);
text(txt, x, y);
}

function isMouseOver(x, y, w, h) {
return mouseX>x-w/2 && mouseX<x+w/2 && mouseY>y-h/2 && mouseY<y+h/2;
}

class Card {
constructor(x, y, w, h, val) {
this.x = x; 
this.y = y; 
this.w = w; 
this.h = h; 
this.val = val;
this.revealed = false; 
this.animScale = 1; 
this.targetScale = 1;
this.hoverScale = 1;
this.targetHoverScale = 1;
}
flip() {
this.revealed = !this.revealed;
this.targetScale = this.revealed ? -1 : 1;
}
update(mx, my, canHover) {
this.animScale = lerp(this.animScale, this.targetScale, 0.2);
if (canHover && !this.revealed && this.isClicked(mx, my)) {
this.targetHoverScale = 1.08;
} else {
this.targetHoverScale = 1;
}
this.hoverScale = lerp(this.hoverScale, this.targetHoverScale, 0.15);
}
display() {
push();
translate(this.x+this.w/2, this.y+this.h/2);
scale(this.animScale*this.hoverScale, this.hoverScale);
rectMode(CENTER); 
stroke(220);

if (this.animScale < 0) {
fill(255);
rect(0, 0, this.w-10, this.h-10);
scale(-1, 1);
noStroke();
textSize(Math.floor(this.w*0.5));
textAlign(CENTER, CENTER);
text(this.val, 0, 0);
} else {
fill(70, 130, 180);
rect(0, 0, this.w-10, this.h-10);
}
pop();
}
getCenter() {
return createVector(this.x+this.w/2, this.y+this.h/2);
}
isClicked(mx, my) {
return mx>this.x && mx<this.x+this.w && my>this.y && my<this.y+this.h;
}
}

class Particle {
constructor(pos) {
this.pos = pos.copy();
this.vel = p5.Vector.random2D().mult(random(2, 5));
this.lifespan = 255;
this.color = color(random(255), random(255), random(255));
}
update() {
this.pos.add(this.vel);
this.lifespan -= 10;
}
display() {
push();
noStroke();
fill(this.color);
ellipse(this.pos.x, this.pos.y, 8);
pop();
}
}

class ParticleSystem {
constructor(pos) {
this.particles = [];
for (let i=0; i<15; i++) {
this.particles.push(new Particle(pos));
}
}
update() {
for (let i=this.particles.length-1; i>=0; i--) {
this.particles[i].update();
if (this.particles[i].lifespan < 0) {
this.particles.splice(i, 1);
}
}
}
display() {
for (let p of this.particles) {
p.display();
}
}
isFinished() {
return this.particles.length === 0;
}
}
</script>

</body>
</html>